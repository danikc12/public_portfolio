<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Lunar Lander - 5 Levels</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { margin: 0; background-color: black; overflow: hidden; }
        button { touch-action: manipulation; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- GLOBAL LANDING CONSTANTS (Simplified for better gameplay) ---
        // If the player is within these limits, they land safely.
        // We no longer make this stricter per level; the terrain/gravity provides the difficulty.
        const SAFE_SPEED = 1.0; 
        const SAFE_ANGLE = 20;  // degrees

        const LunarLander = () => {
            const canvasRef = useRef(null);
            const [gameState, setGameState] = useState('menu');
            const [score, setScore] = useState(0);
            const [fuel, setFuel] = useState(1200);
            const [isMobile, setIsMobile] = useState(false);
            const [currentLevel, setCurrentLevel] = useState(1);
            const [totalScore, setTotalScore] = useState(0);
            
            // Store real-time stats for the UI to display without re-rendering React constantly
            const telemetryRef = useRef({ vx: 0, vy: 0, rot: 0 });

            const gameRef = useRef({
                lander: { x: 100, y: 100, vx: 0.4, vy: 0, rotation: 0 },
                thrust: false,
                rotateLeft: false,
                rotateRight: false,
                gravity: 0.0098,
                thrustPower: 0.018,
                rotationSpeed: 0.7,
                terrain: [],
                landingZones: []
            });

            // --- LEVEL CONFIGURATIONS ---
            const levels = {
                1: {
                    name: "TRAINING MISSION",
                    gravity: 0.0098,
                    thrustPower: 0.018,
                    startVx: 0.3,
                    fuel: 1500,
                    terrain: [
                        { x: 0, y: 550 }, { x: 150, y: 520 }, { x: 300, y: 550 },
                        { x: 450, y: 550 }, { x: 600, y: 520 }, { x: 750, y: 550 },
                        { x: 900, y: 520 }, { x: 1000, y: 550 }
                    ],
                    landingZones: [
                        { x: 150, width: 150, multiplier: 2, label: "2X" },
                        { x: 450, width: 150, multiplier: 2, label: "2X" },
                        { x: 750, width: 150, multiplier: 5, label: "5X" }
                    ]
                },
                2: {
                    name: "ADVANCED DESCENT",
                    gravity: 0.0105,
                    thrustPower: 0.017,
                    startVx: 0.5,
                    fuel: 1300,
                    terrain: [
                        { x: 0, y: 550 }, { x: 100, y: 480 }, { x: 200, y: 450 },
                        { x: 350, y: 480 }, { x: 500, y: 550 }, { x: 650, y: 520 },
                        { x: 750, y: 480 }, { x: 850, y: 450 }, { x: 950, y: 500 },
                        { x: 1000, y: 550 }
                    ],
                    landingZones: [
                        { x: 210, width: 140, multiplier: 2, label: "2X" },
                        { x: 500, width: 150, multiplier: 2, label: "2X" },
                        { x: 810, width: 90, multiplier: 5, label: "5X" }
                    ]
                },
                3: {
                    name: "EXTREME LANDING",
                    gravity: 0.011,
                    thrustPower: 0.0165,
                    startVx: 0.5,
                    fuel: 1200,
                    terrain: [
                        { x: 0, y: 550 }, { x: 100, y: 490 }, { x: 200, y: 450 },
                        { x: 300, y: 480 }, { x: 400, y: 550 }, { x: 500, y: 520 },
                        { x: 600, y: 480 }, { x: 700, y: 450 }, { x: 800, y: 490 },
                        { x: 900, y: 550 }, { x: 1000, y: 550 }
                    ],
                    landingZones: [
                        { x: 180, width: 110, multiplier: 2, label: "2X" },
                        { x: 470, width: 120, multiplier: 2, label: "2X" },
                        { x: 700, width: 85, multiplier: 5, label: "5X" }
                    ]
                },
                4: {
                    name: "THE CANYON",
                    gravity: 0.0115,
                    thrustPower: 0.017,
                    startVx: 0.6,
                    fuel: 1100,
                    terrain: [
                        { x: 0, y: 300 }, { x: 100, y: 350 }, { x: 200, y: 500 }, 
                        { x: 300, y: 550 }, { x: 400, y: 550 }, { x: 500, y: 520 },
                        { x: 600, y: 550 }, { x: 700, y: 550 }, { x: 800, y: 500 },
                        { x: 900, y: 350 }, { x: 1000, y: 300 }
                    ],
                    landingZones: [
                        { x: 300, width: 100, multiplier: 2, label: "2X" },
                        { x: 600, width: 100, multiplier: 2, label: "2X" },
                        { x: 500, width: 60, multiplier: 5, label: "5X" }
                    ]
                },
                5: {
                    name: "ALIEN PEAKS",
                    gravity: 0.0125,
                    thrustPower: 0.018, // slightly more power for heavy gravity
                    startVx: 0.7,
                    fuel: 1000,
                    terrain: [
                        { x: 0, y: 550 }, { x: 150, y: 350 }, { x: 250, y: 450 },
                        { x: 350, y: 250 }, { x: 450, y: 400 }, { x: 550, y: 550 },
                        { x: 650, y: 400 }, { x: 750, y: 250 }, { x: 850, y: 450 },
                        { x: 950, y: 350 }, { x: 1000, y: 550 }
                    ],
                    landingZones: [
                        { x: 240, width: 60, multiplier: 3, label: "3X" },
                        { x: 550, width: 80, multiplier: 2, label: "2X" },
                        { x: 840, width: 60, multiplier: 5, label: "5X" }
                    ]
                }
            };

            useEffect(() => {
                const checkMobile = () => {
                    setIsMobile(window.innerWidth <= 768 || 'ontouchstart' in window);
                };
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            useEffect(() => {
                const levelConfig = levels[currentLevel];
                gameRef.current.terrain = levelConfig.terrain;
                gameRef.current.landingZones = levelConfig.landingZones;
                gameRef.current.gravity = levelConfig.gravity;
                gameRef.current.thrustPower = levelConfig.thrustPower;
            }, [currentLevel]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                let animationId;
                let lastTime = Date.now();

                const handleKeyDown = (e) => {
                    if (gameState === 'menu' && e.key === ' ') {
                        startLevel(1);
                        e.preventDefault();
                        return;
                    }
                    if (gameState !== 'playing') return;
                    if (e.key === 'ArrowUp' || e.key === ' ') {
                        gameRef.current.thrust = true;
                        e.preventDefault();
                    }
                    if (e.key === 'ArrowLeft') {
                        gameRef.current.rotateLeft = true;
                        e.preventDefault();
                    }
                    if (e.key === 'ArrowRight') {
                        gameRef.current.rotateRight = true;
                        e.preventDefault();
                    }
                };

                const handleKeyUp = (e) => {
                    if (e.key === 'ArrowUp' || e.key === ' ') {
                        gameRef.current.thrust = false;
                        e.preventDefault();
                    }
                    if (e.key === 'ArrowLeft') {
                        gameRef.current.rotateLeft = false;
                        e.preventDefault();
                    }
                    if (e.key === 'ArrowRight') {
                        gameRef.current.rotateRight = false;
                        e.preventDefault();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                const gameLoop = () => {
                    const currentTime = Date.now();
                    const deltaTime = Math.min((currentTime - lastTime) / 16.67, 2);
                    lastTime = currentTime;

                    if (gameState === 'playing') {
                        updateGame(deltaTime);
                    }
                    drawGame(ctx);
                    animationId = requestAnimationFrame(gameLoop);
                };

                const updateGame = (deltaTime) => {
                    const game = gameRef.current;
                    const lander = game.lander;

                    if (Math.random() < 0.015) {
                        setScore(s => Math.max(0, s - 1));
                    }

                    if (game.rotateLeft) lander.rotation -= game.rotationSpeed * deltaTime;
                    if (game.rotateRight) lander.rotation += game.rotationSpeed * deltaTime;

                    if (game.thrust && fuel > 0) {
                        const angle = (lander.rotation - 90) * Math.PI / 180;
                        lander.vx += Math.cos(angle) * game.thrustPower * deltaTime;
                        lander.vy += Math.sin(angle) * game.thrustPower * deltaTime;
                        setFuel(f => Math.max(0, f - 0.35 * deltaTime));
                    }

                    lander.vy += game.gravity * deltaTime;
                    
                    // Simple drag
                    lander.vx *= 0.9995;
                    lander.vy *= 0.9995;

                    lander.x += lander.vx * deltaTime;
                    lander.y += lander.vy * deltaTime;

                    // Update telemetry ref for UI
                    telemetryRef.current = {
                        vx: Math.abs(lander.vx),
                        vy: Math.abs(lander.vy),
                        rot: Math.abs(lander.rotation)
                    };

                    // Screen wrapping
                    if (lander.x < -20) lander.x = 1020;
                    if (lander.x > 1020) lander.x = -20;
                    
                    // Ceiling collision (rare but possible)
                    if (lander.y < 0) {
                        setGameState('lost');
                        return;
                    }

                    // Terrain Collision
                    const landerBottom = lander.y + 15;
                    
                    for (let i = 0; i < game.terrain.length - 1; i++) {
                        const p1 = game.terrain[i];
                        const p2 = game.terrain[i + 1];
                        
                        if (lander.x >= p1.x && lander.x <= p2.x) {
                            // Interpolate terrain height at lander x
                            const ratio = (lander.x - p1.x) / (p2.x - p1.x);
                            const terrainY = p1.y + ratio * (p2.y - p1.y);
                            
                            if (landerBottom >= terrainY) {
                                // --- LANDING LOGIC ---
                                
                                // 1. Check if we hit a landing zone
                                let landedZone = null;
                                for (const zone of game.landingZones) {
                                    if (lander.x >= zone.x && lander.x <= zone.x + zone.width) {
                                        landedZone = zone;
                                        break;
                                    }
                                }
                                
                                if (landedZone) {
                                    // 2. Check Physics Metrics
                                    const vSpeed = Math.abs(lander.vy);
                                    const hSpeed = Math.abs(lander.vx);
                                    const rot = Math.abs(lander.rotation);
                                    
                                    // Using the simplified global constants
                                    if (vSpeed < SAFE_SPEED && hSpeed < SAFE_SPEED && rot < SAFE_ANGLE) {
                                        // SUCCESS
                                        const fuelBonus = Math.floor(fuel / 2);
                                        const finalScore = (score + fuelBonus) * landedZone.multiplier;
                                        setScore(finalScore);
                                        setTotalScore(ts => ts + finalScore);
                                        setGameState('levelComplete');
                                    } else {
                                        // FAILED: Hard landing on pad
                                        setGameState('lost');
                                    }
                                } else {
                                    // FAILED: Missed the pad (hit rough terrain)
                                    setGameState('lost');
                                }
                                return;
                            }
                        }
                    }
                };

                const drawGame = (ctx) => {
                    // --- DRAWING LOGIC ---
                    
                    // Background
                    const gradient = ctx.createLinearGradient(0, 0, 0, 600);
                    gradient.addColorStop(0, '#000814');
                    gradient.addColorStop(1, '#001d3d');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 1000, 600);

                    // Stars
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    for (let i = 0; i < 150; i++) {
                        const x = (i * 137.5) % 1000;
                        const y = (i * 219.3) % 450;
                        ctx.fillRect(x, y, 1, 1);
                    }

                    // Earth
                    ctx.save();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#4af';
                    ctx.fillStyle = '#2b7fdb';
                    ctx.beginPath();
                    ctx.arc(850, 80, 32, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    const game = gameRef.current;
                    
                    // Draw Terrain
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(game.terrain[0].x, game.terrain[0].y + 3);
                    for (const point of game.terrain) {
                        ctx.lineTo(point.x, point.y + 3);
                    }
                    ctx.lineTo(1000, 603);
                    ctx.lineTo(0, 603);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Terrain Surface Line
                    ctx.strokeStyle = '#9ca3af';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(game.terrain[0].x, game.terrain[0].y);
                    for (const point of game.terrain) {
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.lineTo(1000, 600);
                    ctx.lineTo(0, 600);
                    ctx.closePath();
                    
                    // Terrain Fill
                    const terrainGradient = ctx.createLinearGradient(0, 400, 0, 600);
                    terrainGradient.addColorStop(0, '#4a5568');
                    terrainGradient.addColorStop(1, '#1a202c');
                    ctx.fillStyle = terrainGradient;
                    ctx.fill();
                    ctx.stroke();

                    // Draw Landing Zones
                    for (const zone of game.landingZones) {
                        const zoneColor = zone.multiplier === 5 ? '#ffff00' : zone.multiplier === 3 ? '#ffa500' : '#00ff00';
                        
                        ctx.save();
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = zoneColor;
                        ctx.strokeStyle = zoneColor;
                        ctx.lineWidth = 6;
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        let started = false;
                        for (let i = 0; i < game.terrain.length - 1; i++) {
                            const p1 = game.terrain[i];
                            const p2 = game.terrain[i + 1];
                            
                            if (p1.x >= zone.x && p1.x <= zone.x + zone.width) {
                                if (!started) {
                                    ctx.moveTo(p1.x, p1.y);
                                    started = true;
                                }
                                ctx.lineTo(p2.x, p2.y);
                            }
                        }
                        ctx.stroke();
                        
                        // Zone Label
                        ctx.fillStyle = zoneColor;
                        ctx.font = 'bold 18px monospace';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 0;
                        ctx.fillText(zone.label, zone.x + zone.width / 2, 580);
                        ctx.textAlign = 'left';
                        ctx.restore();
                    }

                    // Draw Lander
                    if (gameState === 'playing') {
                        const lander = game.lander;
                        ctx.save();
                        ctx.translate(lander.x, lander.y);
                        ctx.rotate(lander.rotation * Math.PI / 180);
                        
                        // Lander Body
                        ctx.fillStyle = '#d4af37'; // Gold
                        ctx.fillRect(-8, -12, 16, 12);
                        
                        // Legs
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-8, 0); ctx.lineTo(-12, 10);
                        ctx.moveTo(8, 0); ctx.lineTo(12, 10);
                        ctx.stroke();
                        
                        // Feet
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-14, 10, 6, 2);
                        ctx.fillRect(8, 10, 6, 2);

                        // Flame
                        if (game.thrust && fuel > 0) {
                            const flameLength = 15 + Math.random() * 8;
                            ctx.fillStyle = '#ff6600';
                            ctx.beginPath();
                            ctx.moveTo(-5, 2);
                            ctx.lineTo(0, 2 + flameLength);
                            ctx.lineTo(5, 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }

                    // --- UI PANEL (TELEMETRY) ---
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(10, 10, 240, 150); // Made slightly taller for more stats
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(10, 10, 240, 150);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText('═══ TELEMETRY ═══', 25, 35);
                    
                    // Score & Fuel
                    ctx.font = '14px monospace';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`SCORE: ${score}`, 25, 60);
                    
                    // Fuel Bar
                    const maxFuel = levels[currentLevel].fuel;
                    const fuelPercent = fuel / maxFuel;
                    ctx.fillStyle = fuelPercent > 0.3 ? '#00ff00' : '#ff0000';
                    ctx.fillRect(80, 70, 100 * fuelPercent, 10);
                    ctx.strokeStyle = '#ffffff';
                    ctx.strokeRect(80, 70, 100, 10);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`FUEL:`, 25, 80);

                    // --- LIVE LANDING METRICS ---
                    // This fixes "It's considered failed". We show the user WHY.
                    // If metric is safe, show GREEN. If unsafe, show RED.
                    
                    const t = telemetryRef.current;
                    const vSpeedColor = t.vy < SAFE_SPEED ? '#00ff00' : '#ff0000';
                    const hSpeedColor = t.vx < SAFE_SPEED ? '#00ff00' : '#ff0000';
                    const rotColor = t.rot < SAFE_ANGLE ? '#00ff00' : '#ff0000';

                    ctx.font = '14px monospace';
                    
                    // Vertical Speed
                    ctx.fillStyle = '#aaaaaa';
                    ctx.fillText("V.SPEED:", 25, 105);
                    ctx.fillStyle = vSpeedColor;
                    ctx.fillText(t.vy.toFixed(2), 100, 105);
                    
                    // Horizontal Speed
                    ctx.fillStyle = '#aaaaaa';
                    ctx.fillText("H.SPEED:", 25, 125);
                    ctx.fillStyle = hSpeedColor;
                    ctx.fillText(t.vx.toFixed(2), 100, 125);
                    
                    // Angle
                    ctx.fillStyle = '#aaaaaa';
                    ctx.fillText("ANGLE:", 25, 145);
                    ctx.fillStyle = rotColor;
                    ctx.fillText(Math.floor(t.rot) + "°", 100, 145);

                    // Level Info
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(770, 10, 220, 50);
                    ctx.strokeStyle = '#00ff00';
                    ctx.strokeRect(770, 10, 220, 50);
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText(`LEVEL ${currentLevel}`, 820, 35);
                    ctx.font = '12px monospace';
                    ctx.fillText(levels[currentLevel].name, 780, 50);

                    // --- GAME STATE MESSAGES ---
                    drawOverlay(ctx);
                };

                const drawOverlay = (ctx) => {
                    if (gameState === 'menu') {
                        drawBox(ctx, '#00ff00', 600, 420);
                        ctx.font = 'bold 42px monospace';
                        ctx.fillStyle = '#00ff00';
                        ctx.fillText('LUNAR LANDER', 350, 170);
                        
                        ctx.font = '16px monospace';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('Select Starting Level:', 400, 220);
                        // Buttons are HTML overlay, text just for decoration
                    }
                    else if (gameState === 'levelComplete') {
                        drawBox(ctx, '#00ff00', 500, 250);
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 36px monospace';
                        ctx.fillText('SUCCESS!', 410, 240);
                        ctx.font = '20px monospace';
                        ctx.fillText(`Score: ${Math.floor(score)}`, 430, 280);
                        
                        if (currentLevel === 5) {
                            ctx.fillStyle = '#ffff00';
                            ctx.fillText('MISSION COMPLETE!', 390, 320);
                        }
                    }
                    else if (gameState === 'lost') {
                        drawBox(ctx, '#ff0000', 440, 200);
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 40px monospace';
                        ctx.fillText('CRASHED', 410, 255);
                        
                        // Explain why they crashed
                        ctx.font = '16px monospace';
                        ctx.fillStyle = '#ffaaaa';
                        
                        const t = telemetryRef.current;
                        let reason = "Hit rough terrain";
                        
                        // Check if they were over a pad but failed physics
                        const game = gameRef.current;
                        const lander = game.lander;
                        const landerBottom = lander.y + 15;
                        
                        // Quick check if we were near ground
                        if (landerBottom > 200) {
                            if (t.vy >= SAFE_SPEED) reason = "Too fast (Vertical)";
                            else if (t.vx >= SAFE_SPEED) reason = "Too fast (Horizontal)";
                            else if (t.rot >= SAFE_ANGLE) reason = "Bad Angle";
                        }
                        
                        ctx.fillText(`Cause: ${reason}`, 380, 300);
                    }
                }

                const drawBox = (ctx, color, w, h) => {
                    const x = (1000 - w) / 2;
                    const y = (600 - h) / 2;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x, y, w, h);
                }

                gameLoop();

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    cancelAnimationFrame(animationId);
                };
            }, [gameState, fuel, score, currentLevel, totalScore]);

            const startLevel = (level) => {
                const levelConfig = levels[level];
                setCurrentLevel(level);
                gameRef.current.lander = { x: 100, y: 100, vx: levelConfig.startVx, vy: 0, rotation: 0 };
                gameRef.current.thrust = false;
                gameRef.current.rotateLeft = false;
                gameRef.current.rotateRight = false;
                setFuel(levelConfig.fuel);
                setScore(1000);
                setGameState('playing');
            };

            const nextLevel = () => {
                if (currentLevel < 5) {
                    startLevel(currentLevel + 1);
                } else {
                    setGameState('menu');
                    setTotalScore(0);
                    setCurrentLevel(1);
                }
            };

            const restartLevel = () => {
                startLevel(currentLevel);
            };

            const backToMenu = () => {
                setGameState('menu');
                setTotalScore(0);
                setCurrentLevel(1);
            };

            // Touch controls
            const handleTouchStart = (control) => {
                if (gameState !== 'playing') return;
                if (control === 'thrust') gameRef.current.thrust = true;
                if (control === 'left') gameRef.current.rotateLeft = true;
                if (control === 'right') gameRef.current.rotateRight = true;
            };

            const handleTouchEnd = (control) => {
                if (control === 'thrust') gameRef.current.thrust = false;
                if (control === 'left') gameRef.current.rotateLeft = false;
                if (control === 'right') gameRef.current.rotateRight = false;
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-black p-4">
                    <div className="relative w-full max-w-4xl">
                        <canvas
                            ref={canvasRef}
                            width={1000}
                            height={600}
                            className="border-4 border-cyan-500 rounded-lg shadow-2xl shadow-cyan-500/50 w-full h-auto"
                        />
                    </div>
                    
                    {/* Mobile Controls */}
                    {isMobile && gameState === 'playing' && (
                        <div className="fixed bottom-8 left-0 right-0 flex justify-between items-end px-4 gap-4" style={{ maxWidth: '100%' }}>
                            <button
                                onTouchStart={() => handleTouchStart('left')}
                                onTouchEnd={() => handleTouchEnd('left')}
                                onMouseDown={() => handleTouchStart('left')}
                                onMouseUp={() => handleTouchEnd('left')}
                                onMouseLeave={() => handleTouchEnd('left')}
                                className="w-20 h-20 bg-blue-600 active:bg-blue-700 text-white font-bold text-2xl rounded-lg border-4 border-blue-400 opacity-80"
                                style={{ touchAction: 'none', userSelect: 'none' }}
                            >←</button>
                            
                            <button
                                onTouchStart={() => handleTouchStart('thrust')}
                                onTouchEnd={() => handleTouchEnd('thrust')}
                                onMouseDown={() => handleTouchStart('thrust')}
                                onMouseUp={() => handleTouchEnd('thrust')}
                                onMouseLeave={() => handleTouchEnd('thrust')}
                                className="w-24 h-24 bg-red-600 active:bg-red-700 text-white font-bold text-3xl rounded-full border-4 border-red-400 opacity-80"
                                style={{ touchAction: 'none', userSelect: 'none' }}
                            >↑</button>
                            
                            <button
                                onTouchStart={() => handleTouchStart('right')}
                                onTouchEnd={() => handleTouchEnd('right')}
                                onMouseDown={() => handleTouchStart('right')}
                                onMouseUp={() => handleTouchEnd('right')}
                                onMouseLeave={() => handleTouchEnd('right')}
                                className="w-20 h-20 bg-blue-600 active:bg-blue-700 text-white font-bold text-2xl rounded-lg border-4 border-blue-400 opacity-80"
                                style={{ touchAction: 'none', userSelect: 'none' }}
                            >→</button>
                        </div>
                    )}
                    
                    <div className="mt-6 flex gap-4 flex-wrap justify-center z-10">
                        {gameState === 'menu' && (
                            <div className="grid grid-cols-5 gap-2">
                                {[1, 2, 3, 4, 5].map(lvl => (
                                    <button
                                        key={lvl}
                                        onClick={() => startLevel(lvl)}
                                        className={`px-4 py-3 text-white font-mono rounded-lg border-2 shadow-lg ${
                                            lvl === 1 ? 'bg-green-600 border-green-400' :
                                            lvl === 2 ? 'bg-teal-600 border-teal-400' :
                                            lvl === 3 ? 'bg-yellow-600 border-yellow-400' :
                                            lvl === 4 ? 'bg-orange-600 border-orange-400' :
                                            'bg-red-600 border-red-400'
                                        }`}
                                    >
                                        LVL {lvl}
                                    </button>
                                ))}
                            </div>
                        )}
                        
                        {(gameState === 'levelComplete' || gameState === 'lost') && (
                            <>
                                {gameState === 'levelComplete' && currentLevel < 5 && (
                                    <button onClick={nextLevel} className="px-8 py-4 bg-green-600 text-white font-mono rounded-lg border-2 border-green-400">
                                        ▶ NEXT LEVEL
                                    </button>
                                )}
                                <button onClick={restartLevel} className="px-8 py-4 bg-yellow-600 text-white font-mono rounded-lg border-2 border-yellow-400">
                                    ↻ RETRY
                                </button>
                                <button onClick={backToMenu} className="px-8 py-4 bg-blue-600 text-white font-mono rounded-lg border-2 border-blue-400">
                                    ⌂ MENU
                                </button>
                            </>
                        )}
                    </div>

                    <div className="mt-4 text-gray-400 text-sm font-mono text-center max-w-2xl px-4">
                        <p>Safe Limits: Speed &lt; 1.0 • Angle &lt; 20°</p>
                        <p className="text-cyan-400">Watch the Telemetry panel! Green numbers = Safe to Land.</p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LunarLander />);
    </script>
</body>
</html>